---
title: "4308_proj_taylor"
author: "Erica"
date: "2025-11-05"
output: html_document
---

```{r}
# ---- packages ----
library (readr)
library (dplyr)
library (lubridate)
library (stringr)
```

#### Inflation Rate
```{r}
# ---- helper: YoY log change from level CPI ---
yoy_log = function(x, lag_n = 12) {
  log(x) - dplyr::lag(log(x), lag_n)
}

# ---- US inflation rate ----
us_path = '../data/cpi_us_fred_md_raw.csv'
us_raw = read_csv(us_path, show_col_types = FALSE)
us_raw = us_raw %>% filter(date >= '1974-01-01')
us = us_raw %>% mutate(pi_us = yoy_log(CPIAUCSL)) %>%
  filter(!is.na(pi_us))

# ---- JP inflation rate ----
jp_path = '../data/cpi_jp_self_sourced.csv'
jp_raw = read_csv(jp_path, show_col_types = FALSE)
jp_raw = jp_raw %>% filter(date >= '1974-01-01')
jp = jp_raw %>% mutate(pi_jp = yoy_log(cpijp)) %>%
  filter(!is.na(pi_jp))
```

#### Output Gap (one-sided HP) from Industrial Production
```{r}
library(KFAS)

# ---- helper function ----
one_sided_hp_gap <- function(x, lambda = 14400, log_transform = TRUE){
  v <- as.numeric(x); if (log_transform){ v[v<=0] <- NA; v <- log(v) }
  kf <- KFS(SSModel(v ~ SSMtrend(2, Q=list(0, 1/lambda)), H=1),
            filtering="state", smoothing="none")
  trend <- as.numeric(kf$a[-1,1]); 100 * (v - trend)
}

# ---- US IP Gap ----
us_ip_path = '../data/indpro_us_fred_md_raw.csv'
us_ip_raw = read_csv(us_ip_path, show_col_types = FALSE)
us_ip_raw = us_ip_raw %>% 
  distinct(date, .keep_all = TRUE) %>%
  filter(date >= '1974-01-01')

us_gap <- us_ip_raw %>%
  mutate(gap_us = one_sided_hp_gap(INDPRO, 14400)) %>%
  select(date, gap_us)

# ---- helper function to reconstruct the level data ----
reconstruct_from_dlog <- function(dlog, base = 100) {
  idx <- which(!is.na(dlog)); stopifnot(length(idx) > 0)
  lvl <- rep(NA_real_, length(dlog))
  lvl[idx] <- exp(log(base) + cumsum(replace(dlog[idx], is.na(dlog[idx]), 0)))
  lvl
}

# ---- JP IP Gap ----
jp_ip_path = '../data/iip_jp.csv'
jp_ip_raw = read_csv(jp_ip_path, show_col_types = FALSE)
jp_ip_raw = jp_ip_raw %>% filter (date >= '1974-01-01')
jp_gap <- jp_ip_raw %>%
  mutate(
    iip_level = reconstruct_from_dlog(iipjp, base = 1),
    gap_jp    = one_sided_hp_gap(iip_level, lambda = 14400) * 0.01
  ) %>%
  transmute(date, gap_jp)

```

#### policy/short rates
```{r}
# ---- US rate ----
us_rate_path = '../data/fedfund_us.csv'
us_rate_raw = read_csv(us_rate_path, show_col_types = FALSE) %>%
  filter(date >= "1974-01-01") %>% 
  mutate(i_us_l1 = FEDFUNDS) %>% select (date, i_us_l1)

# ---- JP rate ----
jp_rate_path = '../data/rate_jp.csv'
jp_rate_raw = read_csv(jp_rate_path, show_col_types = FALSE) %>% 
  filter (date >= '1974-01-01') %>%
  mutate (i_jp_l1 = rate) %>%
  select (date, i_jp_l1)
```

#### Predictors Dataset
```{r}
# ---- join regressors to returns
regs <- us %>% select(date, pi_us) %>%
  inner_join(jp %>% select(date, pi_jp), by = "date") %>%
  inner_join(us_gap %>% select(date, gap_us), by = "date") %>%
  inner_join(jp_gap %>% select(date, gap_jp), by = "date") %>%
  inner_join(us_rate_raw %>% select(date, i_us_l1), by = "date") %>%
  inner_join(jp_rate_raw %>% select(date, i_jp_l1), by = "date")
```

#### Plotting Helper
```{r}
library(ggplot2)
library(scales)
plot_backtest <- function(oos, summary_row, target_col, h_label = NULL) {
  stopifnot(all(c("date","f_tr","f_rw0") %in% names(oos)))
  if (is.null(h_label)) h_label <- summary_row$h %||% summary_row$horizon %||% "h"

  first_decision <- as.Date(summary_row$first_decision_date)
  rmse_tr  <- signif(summary_row$RMSE_TR %||% summary_row$RMSE_AR1 %||% summary_row$RMSE_PCR, 3)
  rmse_rw0 <- signif(summary_row$RMSE_RW0, 3)
  da_tr    <- signif(summary_row$DA_TR %||% summary_row$DA_AR1 %||% summary_row$DA_PCR, 3)

  df_long <- oos %>%
    transmute(date,
              Actual = .data[[target_col]],
              `Model (TR/OLS)` = f_tr,
              `RW(0)` = f_rw0) %>%
    pivot_longer(-date, names_to = "series", values_to = "value")

  ggplot(df_long, aes(date, value, color = series)) +
    geom_hline(yintercept = 0, linewidth = 0.25, linetype = "dashed", color = "grey50") +
    geom_vline(xintercept = first_decision, linewidth = 0.4, linetype = "dotdash", color = "grey40") +
    geom_line(linewidth = 0.6, na.rm = TRUE) +
    labs(
      title    = paste0("Rolling Backtest (horizon = ", h_label, ")"),
      subtitle = paste0("First decision date: ", first_decision,
                        " | RMSE(Model) = ", rmse_tr,
                        " | RMSE(RW0) = ", rmse_rw0,
                        " | DA(Model) = ", da_tr),
      x = NULL, y = "Log return",
      color = NULL
    ) +
    scale_x_date(labels = label_date_short()) +
    theme_minimal(base_size = 11) +
    theme(legend.position = "top",
          panel.grid.minor = element_blank())
}
```
#### Forecast Horizon = 1 month; Validation = Rolling Window
```{r}
fx <- read_csv("../data/df_1m_lag.csv", show_col_types = FALSE) %>%
  select(date, Y_log_return_1m) %>%
  arrange(date) %>%
  filter(!is.na(Y_log_return_1m))

base <- fx %>%
  mutate(date = as.Date(date)) %>%
  inner_join(regs, by = "date") %>%
  arrange(date) %>%
  filter(date <= as.Date("2022-12-31"))

# ---- rolling OLS with fixed window determined at cutoff
roll_ols_multi <- function(dat_h, h, cutoff_date){
  dat_h <- dat_h %>% 
    tidyr::drop_na(Y_log_return_1m, pi_us, pi_jp, gap_us, gap_jp, i_us_l1, i_jp_l1)

  # window size = usable rows up to cutoff (labels known up to cutoff)
  W <- dat_h %>% filter(date <= cutoff_date) %>% nrow()

  # first decision date index (D = cutoff + h months)
  D0 <- cutoff_date %m+% months(h)
  i_start <- which(dat_h$date == D0)
  if (length(i_start) == 0) stop("First decision date not found in data.")

  n <- nrow(dat_h)
  yhat_tr  <- rep(NA_real_, n)
  yhat_rw0 <- rep(0, n)

  for (i in i_start:n){
    tr_end   <- i - h
    tr_start <- tr_end - W + 1
    if (tr_start < 1) next

    fit <- lm(Y_log_return_1m ~ pi_us + pi_jp + gap_us + gap_jp + i_us_l1 + i_jp_l1,
              data = dat_h[tr_start:tr_end, ])

    yhat_tr[i] <- predict(fit, newdata = dat_h[i, , drop = FALSE])
  }

  oos <- dat_h %>%
    mutate(f_tr = yhat_tr, f_rw0 = yhat_rw0) %>%
    filter(!is.na(f_tr))

  rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
  e_tr  <- oos$Y_log_return_1m - oos$f_tr
  e_rw0 <- oos$Y_log_return_1m - oos$f_rw0

  # ---- directional accuracy (exclude zeros) ----
  da <- function(y, yhat, drop_zero = TRUE) {
    sy <- sign(y); sf <- sign(yhat)
    ok <- is.finite(sy) & is.finite(sf)
    if (drop_zero) ok <- ok & sy != 0 & sf != 0
    if (!any(ok)) return(NA_real_)
    mean(sy[ok] == sf[ok])
  }
  DA_TR  <- da(oos$Y_log_return_1m, oos$f_tr,  drop_zero = TRUE)
  DA_RW0 <- da(oos$Y_log_return_1m, oos$f_rw0, drop_zero = TRUE)

  summary <- tibble::tibble(
    h = h,
    window_W = W,
    first_decision_date = dat_h$date[i_start],
    n_oos = nrow(oos),
    RMSE_TR   = rmse(oos$Y_log_return_1m, oos$f_tr),
    RMSE_RW0  = rmse(oos$Y_log_return_1m, oos$f_rw0),
    R2_OOS_vs_RW0 = 1 - sum(e_tr^2) / sum(e_rw0^2),
    DA_TR     = DA_TR,
    DA_RW0    = DA_RW0
  )

  list(summary = summary, oos = oos)
}

# ---- fit and run
h <- 1
cutoff <- as.Date("2012-12-01")

out <- roll_ols_multi(base, h, cutoff)
summary_tbl <- out$summary
oos_1m      <- out$oos

print(summary_tbl)
# head(oos_1m)

```
#### Plot 1-month backtest period = 10 years
```{r}
p_1m <- plot_backtest(
  oos         = oos_1m,
  summary_row = summary_tbl,            # one-row tibble
  target_col  = "Y_log_return_1m",
  h_label     = paste0(summary_tbl$h, "m")
)
print(p_1m)
```

#### Forecast Horizon = 3 months; Validation = Rolling Window
```{r}
fx <- read_csv("../data/df_3m_lag.csv", show_col_types = FALSE) %>%
  select(date, Y_log_return_3m) %>%
  arrange(date) %>%
  filter(!is.na(Y_log_return_3m))

base <- fx %>%
  mutate(date = as.Date(date)) %>%
  inner_join(regs, by = "date") %>%
  arrange(date) %>%
  filter(date <= as.Date("2022-12-31"))

# ---- rolling OLS with fixed window determined at cutoff
roll_ols_multi <- function(dat_h, h, cutoff_date){
  dat_h <- dat_h %>% 
    tidyr::drop_na(Y_log_return_3m, pi_us, pi_jp, gap_us, gap_jp, i_us_l1, i_jp_l1)

  # window size = usable rows up to cutoff (labels known up to cutoff)
  W <- dat_h %>% filter(date <= cutoff_date) %>% nrow()

  # first decision date index (D = cutoff + h months)
  D0 <- cutoff_date %m+% months(h)
  i_start <- which(dat_h$date == D0)
  if (length(i_start) == 0) stop("First decision date not found in data.")

  n <- nrow(dat_h)
  yhat_tr  <- rep(NA_real_, n)
  yhat_rw0 <- rep(0, n)

  for (i in i_start:n){
    tr_end   <- i - h
    tr_start <- tr_end - W + 1
    if (tr_start < 1) next

    fit <- lm(Y_log_return_3m ~ pi_us + pi_jp + gap_us + gap_jp + i_us_l1 + i_jp_l1,
              data = dat_h[tr_start:tr_end, ])

    yhat_tr[i] <- predict(fit, newdata = dat_h[i, , drop = FALSE])
  }

  oos <- dat_h %>%
    mutate(f_tr = yhat_tr, f_rw0 = yhat_rw0) %>%
    filter(!is.na(f_tr))

  rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
  e_tr  <- oos$Y_log_return_3m - oos$f_tr
  e_rw0 <- oos$Y_log_return_3m - oos$f_rw0

  # ---- directional accuracy (exclude zeros) ----
  da <- function(y, yhat, drop_zero = TRUE) {
    sy <- sign(y); sf <- sign(yhat)
    ok <- is.finite(sy) & is.finite(sf)
    if (drop_zero) ok <- ok & sy != 0 & sf != 0
    if (!any(ok)) return(NA_real_)
    mean(sy[ok] == sf[ok])
  }
  DA_TR  <- da(oos$Y_log_return_3m, oos$f_tr,  drop_zero = TRUE)
  DA_RW0 <- da(oos$Y_log_return_3m, oos$f_rw0, drop_zero = TRUE)

  summary <- tibble::tibble(
    h = h,
    window_W = W,
    first_decision_date = dat_h$date[i_start],
    n_oos = nrow(oos),
    RMSE_TR   = rmse(oos$Y_log_return_3m, oos$f_tr),
    RMSE_RW0  = rmse(oos$Y_log_return_3m, oos$f_rw0),
    R2_OOS_vs_RW0 = 1 - sum(e_tr^2) / sum(e_rw0^2),
    DA_TR     = DA_TR,
    DA_RW0    = DA_RW0
  )

  list(summary = summary, oos = oos)
}

# ---- fit and run
h <- 3
cutoff <- as.Date("2012-12-01")

out <- roll_ols_multi(base, h, cutoff)
summary_tbl <- out$summary
oos_3m      <- out$oos

print(summary_tbl)
# head(oos_3m)
```

#### Plot 1-month backtest period = 10 years
```{r}
p_3m <- plot_backtest(
  oos         = oos_3m,
  summary_row = summary_tbl,            # one-row tibble
  target_col  = "Y_log_return_3m",
  h_label     = paste0(summary_tbl$h, "m")
)
print(p_3m)
```

#### Forecast Horizon = 6 months; Validation = Rolling Window
```{r}
fx <- read_csv("../data/df_6m_lag.csv", show_col_types = FALSE) %>%
  select(date, Y_log_return_6m) %>%
  arrange(date) %>%
  filter(!is.na(Y_log_return_6m))

base <- fx %>%
  mutate(date = as.Date(date)) %>%
  inner_join(regs, by = "date") %>%
  arrange(date) %>%
  filter(date <= as.Date("2022-12-31"))

# ---- rolling OLS with fixed window determined at cutoff
roll_ols_multi <- function(dat_h, h, cutoff_date){
  dat_h <- dat_h %>% 
    tidyr::drop_na(Y_log_return_6m, pi_us, pi_jp, gap_us, gap_jp, i_us_l1, i_jp_l1)

  # window size = usable rows up to cutoff (labels known up to cutoff)
  W <- dat_h %>% filter(date <= cutoff_date) %>% nrow()

  # first decision date index (D = cutoff + h months)
  D0 <- cutoff_date %m+% months(h)
  i_start <- which(dat_h$date == D0)
  if (length(i_start) == 0) stop("First decision date not found in data.")

  n <- nrow(dat_h)
  yhat_tr  <- rep(NA_real_, n)
  yhat_rw0 <- rep(0, n)

  for (i in i_start:n){
    tr_end   <- i - h
    tr_start <- tr_end - W + 1
    if (tr_start < 1) next

    fit <- lm(Y_log_return_6m ~ pi_us + pi_jp + gap_us + gap_jp + i_us_l1 + i_jp_l1,
              data = dat_h[tr_start:tr_end, ])

    yhat_tr[i] <- predict(fit, newdata = dat_h[i, , drop = FALSE])
  }

  oos <- dat_h %>%
    mutate(f_tr = yhat_tr, f_rw0 = yhat_rw0) %>%
    filter(!is.na(f_tr))

  rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
  e_tr  <- oos$Y_log_return_6m - oos$f_tr
  e_rw0 <- oos$Y_log_return_6m - oos$f_rw0

  # ---- directional accuracy (exclude zeros) ----
  da <- function(y, yhat, drop_zero = TRUE) {
    sy <- sign(y); sf <- sign(yhat)
    ok <- is.finite(sy) & is.finite(sf)
    if (drop_zero) ok <- ok & sy != 0 & sf != 0
    if (!any(ok)) return(NA_real_)
    mean(sy[ok] == sf[ok])
  }
  DA_TR  <- da(oos$Y_log_return_6m, oos$f_tr,  drop_zero = TRUE)
  DA_RW0 <- da(oos$Y_log_return_6m, oos$f_rw0, drop_zero = TRUE)

  summary <- tibble::tibble(
    h = h,
    window_W = W,
    first_decision_date = dat_h$date[i_start],
    n_oos = nrow(oos),
    RMSE_TR   = rmse(oos$Y_log_return_6m, oos$f_tr),
    RMSE_RW0  = rmse(oos$Y_log_return_6m, oos$f_rw0),
    R2_OOS_vs_RW0 = 1 - sum(e_tr^2) / sum(e_rw0^2),
    DA_TR     = DA_TR,
    DA_RW0    = DA_RW0
  )

  list(summary = summary, oos = oos)
}

# ---- fit and run
h <- 6
cutoff <- as.Date("2012-12-01")

out <- roll_ols_multi(base, h, cutoff)
summary_tbl <- out$summary
oos_6m      <- out$oos

print(summary_tbl)
```
#### Plot 1-month backtest period = 10 years
```{r}
p_6m <- plot_backtest(
  oos         = oos_6m,
  summary_row = summary_tbl,            # one-row tibble
  target_col  = "Y_log_return_6m",
  h_label     = paste0(summary_tbl$h, "m")
)
print(p_6m)
```

#### Forecast Horizon = 12 months; Validation = Rolling Window
```{r}
fx <- read_csv("../data/df_12m_lag.csv", show_col_types = FALSE) %>%
  select(date, Y_log_return_12m) %>%
  arrange(date) %>%
  filter(!is.na(Y_log_return_12m))

base <- fx %>%
  mutate(date = as.Date(date)) %>%
  inner_join(regs, by = "date") %>%
  arrange(date) %>%
  filter(date <= as.Date("2022-12-31"))

# ---- rolling OLS with fixed window determined at cutoff
roll_ols_multi <- function(dat_h, h, cutoff_date){
  dat_h <- dat_h %>% 
    tidyr::drop_na(Y_log_return_12m, pi_us, pi_jp, gap_us, gap_jp, i_us_l1, i_jp_l1)

  # window size = usable rows up to cutoff (labels known up to cutoff)
  W <- dat_h %>% filter(date <= cutoff_date) %>% nrow()

  # first decision date index (D = cutoff + h months)
  D0 <- cutoff_date %m+% months(h)
  i_start <- which(dat_h$date == D0)
  if (length(i_start) == 0) stop("First decision date not found in data.")

  n <- nrow(dat_h)
  yhat_tr  <- rep(NA_real_, n)
  yhat_rw0 <- rep(0, n)

  for (i in i_start:n){
    tr_end   <- i - h
    tr_start <- tr_end - W + 1
    if (tr_start < 1) next

    fit <- lm(Y_log_return_12m ~ pi_us + pi_jp + gap_us + gap_jp + i_us_l1 + i_jp_l1,
              data = dat_h[tr_start:tr_end, ])

    yhat_tr[i] <- predict(fit, newdata = dat_h[i, , drop = FALSE])
  }

  oos <- dat_h %>%
    mutate(f_tr = yhat_tr, f_rw0 = yhat_rw0) %>%
    filter(!is.na(f_tr))

  rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
  e_tr  <- oos$Y_log_return_12m - oos$f_tr
  e_rw0 <- oos$Y_log_return_12m - oos$f_rw0

  # ---- directional accuracy (exclude zeros) ----
  da <- function(y, yhat, drop_zero = TRUE) {
    sy <- sign(y); sf <- sign(yhat)
    ok <- is.finite(sy) & is.finite(sf)
    if (drop_zero) ok <- ok & sy != 0 & sf != 0
    if (!any(ok)) return(NA_real_)
    mean(sy[ok] == sf[ok])
  }
  DA_TR  <- da(oos$Y_log_return_12m, oos$f_tr,  drop_zero = TRUE)
  DA_RW0 <- da(oos$Y_log_return_12m, oos$f_rw0, drop_zero = TRUE)

  summary <- tibble::tibble(
    h = h,
    window_W = W,
    first_decision_date = dat_h$date[i_start],
    n_oos = nrow(oos),
    RMSE_TR   = rmse(oos$Y_log_return_12m, oos$f_tr),
    RMSE_RW0  = rmse(oos$Y_log_return_12m, oos$f_rw0),
    R2_OOS_vs_RW0 = 1 - sum(e_tr^2) / sum(e_rw0^2),
    DA_TR     = DA_TR,
    DA_RW0    = DA_RW0
  )

  list(summary = summary, oos = oos)
}

# ---- fit and run
h <- 12
cutoff <- as.Date("2012-12-01")

out <- roll_ols_multi(base, h, cutoff)
summary_tbl <- out$summary
oos_12m      <- out$oos

print(summary_tbl)
```

```{r}
p_12m <- plot_backtest(
  oos         = oos_12m,
  summary_row = summary_tbl,            # one-row tibble
  target_col  = "Y_log_return_12m",
  h_label     = paste0(summary_tbl$h, "m")
)
print(p_12m)
```

```{r}
fixed_split_ols <- function(dat, target_col, cutoff_date, h) {
  dat <- dat %>%
    mutate(date = as.Date(date)) %>%
    arrange(date)

  # predictors = all except date + target (numeric only)
  pred_cols <- setdiff(names(dat), c("date", target_col))
  pred_cols <- pred_cols[sapply(dat[pred_cols], is.numeric)]

  # drop NAs
  dat <- dat %>% drop_na(all_of(c(target_col, pred_cols)))

  # IMPORTANT: labels Y_h(t)=log X_{t+h}-log X_t need t+h â‰¤ cutoff
  train_end <- cutoff_date %m-% months(h)

  train <- dat %>% filter(date <= train_end)
  test  <- dat %>% filter(date  >  cutoff_date)

  if (nrow(train) < 10L) stop("Too few train rows for horizon h=", h)
  if (nrow(test)  <  1L) stop("No test rows after cutoff.")

  fml <- reformulate(termlabels = pred_cols, response = target_col)
  fit <- lm(fml, data = train)

  test <- test %>%
    mutate(
      f_ols = as.numeric(predict(fit, newdata = cur_data())),
      f_rw0 = 0
    ) %>%
    drop_na(f_ols)

  y   <- test[[target_col]]
  e_m <- y - test$f_ols
  e_rw<- y - test$f_rw0
  rmse <- function(z) sqrt(mean(z^2, na.rm = TRUE))

  # Directional Accuracy (exclude zeros by default)
  da <- function(y, yhat, drop_zero = TRUE) {
    sy <- sign(y); sf <- sign(yhat)
    ok <- is.finite(sy) & is.finite(sf)
    if (drop_zero) ok <- ok & sy != 0 & sf != 0
    if (!any(ok)) return(NA_real_)
    mean(sy[ok] == sf[ok])
  }

  summary <- tibble::tibble(
    horizon_h         = h,
    cutoff_date       = cutoff_date,
    train_end         = train_end,
    n_train           = nrow(train),
    n_test            = nrow(test),
    test_start        = min(test$date),
    test_end          = max(test$date),
    RMSE_OLS          = rmse(e_m),
    RMSE_RW0          = rmse(e_rw),
    R2_OOS_vs_RW0     = 1 - sum(e_m^2) / sum(e_rw^2),
    DA_OLS            = da(y, test$f_ols, drop_zero = TRUE),
    DA_RW0            = da(y, test$f_rw0, drop_zero = TRUE)
  )

  list(summary = summary, oos = test %>% select(date, !!target_col, f_ols, f_rw0))
}

cutoff <- as.Date("2012-12-01")

# 1m
base_1m <- read_csv("../data/df_1m_lag.csv", show_col_types = FALSE) %>%
  select(date, Y_log_return_1m) %>%
  arrange(date) %>% filter(!is.na(Y_log_return_1m)) %>%
  mutate(date = as.Date(date)) %>% inner_join(regs, by = "date") %>%
  arrange(date) %>% filter(date <= as.Date("2022-12-31"))
res_1m  <- fixed_split_ols(base_1m, "Y_log_return_1m", cutoff, h = 1)

# 3m
base_3m <- read_csv("../data/df_3m_lag.csv", show_col_types = FALSE) %>%
  select(date, Y_log_return_3m) %>%
  arrange(date) %>% filter(!is.na(Y_log_return_3m)) %>%
  mutate(date = as.Date(date)) %>% inner_join(regs, by = "date") %>%
  arrange(date) %>% filter(date <= as.Date("2022-12-31"))
res_3m  <- fixed_split_ols(base_3m, "Y_log_return_3m", cutoff, h = 3)

# 6m
base_6m <- read_csv("../data/df_6m_lag.csv", show_col_types = FALSE) %>%
  select(date, Y_log_return_6m) %>%
  arrange(date) %>% filter(!is.na(Y_log_return_6m)) %>%
  mutate(date = as.Date(date)) %>% inner_join(regs, by = "date") %>%
  arrange(date) %>% filter(date <= as.Date("2022-12-31"))
res_6m  <- fixed_split_ols(base_6m, "Y_log_return_6m", cutoff, h = 6)

# 12m
base_12m <- read_csv("../data/df_12m_lag.csv", show_col_types = FALSE) %>%
  select(date, Y_log_return_12m) %>%
  arrange(date) %>% filter(!is.na(Y_log_return_12m)) %>%
  mutate(date = as.Date(date)) %>% inner_join(regs, by = "date") %>%
  arrange(date) %>% filter(date <= as.Date("2022-12-31"))
res_12m <- fixed_split_ols(base_12m, "Y_log_return_12m", cutoff, h = 12)

summary_tbl <- dplyr::bind_rows(
  res_1m$summary %>% mutate(horizon = "1m"),
  res_3m$summary %>% mutate(horizon = "3m"),
  res_6m$summary %>% mutate(horizon = "6m"),
  res_12m$summary %>% mutate(horizon = "12m")
) %>% select(horizon, everything())

print(summary_tbl)
# Per-horizon OOS predictions:
# res_1m$oos ; res_3m$oos ; res_6m$oos ; res_12m$oos

```

















