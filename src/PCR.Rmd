---
title: "PCR"
author: "Erica"
date: "2025-11-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(lubridate)
library(tidyr)
```

```{r}
inspect_pcr_components <- function(fit, Kstar = NULL, topN = 10) {
  stopifnot(inherits(fit, "mvr"))
  L <- as.matrix(pls::loadings(fit))                 # p x Kcap (may be 0 cols)
  Kcap <- if (length(dim(L)) == 0) 0L else ncol(L)
  vx <- as.numeric(pls::explvar(fit))                # % X variance per PC
  cum_vx <- if (length(vx)) cumsum(vx) else numeric(0)
  T_scores <- if (Kcap > 0) as.matrix(pls::scores(fit)) else matrix(numeric(0),0,0)

  if (is.null(Kstar)) Kstar <- Kcap
  Kstar <- max(0L, min(Kstar, Kcap))

  pc_loadings <-
    if (Kstar > 0) {
      tibble::tibble(
        variable = rownames(L),
        !!!setNames(as.list(as.data.frame(L[, 1:Kstar, drop = FALSE])), paste0("PC", seq_len(Kstar)))
      )
    } else tibble::tibble(variable = character(0))

  vx_report <-
    if (length(vx)) tibble::tibble(PC = paste0("PC", seq_along(vx)),
                                   var_explained_pct = vx, cum_pct = cum_vx)
    else tibble::tibble(PC = character(0), var_explained_pct = numeric(0), cum_pct = numeric(0))

  top_contrib <-
    if (Kcap > 0) {
      dplyr::bind_rows(lapply(seq_len(Kcap), function(k){
        w <- L[,k]; contrib <- 100*(w^2)/sum(w^2)
        idx <- order(contrib, decreasing = TRUE)
        take <- head(idx, min(topN, length(idx)))
        tibble::tibble(PC = paste0("PC", k),
                       variable = rownames(L)[take],
                       loading = w[take],
                       contrib_pct = contrib[take])
      }))
    } else tibble::tibble(PC=character(0), variable=character(0), loading=numeric(0), contrib_pct=numeric(0))

  list(pc_loadings=pc_loadings, vx_report=vx_report, top_contrib=top_contrib,
       scores=T_scores, ncomp=Kcap)
}

# ---------- rolling PCR with BIC; captures PC tables from first good window ----------
roll_pcr_bic_pls <- function(dat, target_col, pred_cols, h, cutoff_date, Kmax = 10,
                             Kstar_report = 3, topN_report = 8) {
  d <- dat %>%
    dplyr::select(date, dplyr::all_of(target_col), dplyr::all_of(pred_cols)) %>%
    dplyr::arrange(date) %>%
    tidyr::drop_na(!!rlang::sym(target_col), dplyr::all_of(pred_cols))

  W <- d %>% dplyr::filter(date <= cutoff_date) %>% nrow()
  if (W < 12) stop("Not enough rows before cutoff to form a window.")

  D0 <- cutoff_date %m+% months(h)
  i_start <- which(d$date == D0)
  if (!length(i_start)) stop("First decision date not found (check dates).")

  n <- nrow(d)
  yhat_pcr <- rep(NA_real_, n)
  yhat_rw0 <- rep(0, n)
  K_pick   <- rep(NA_integer_, n)

  # holders for PC reporting
  pc_info <- NULL
  pc_window <- NULL

  for (i in i_start:n) {
    tr_end   <- i - h
    tr_start <- tr_end - W + 1
    if (tr_start < 1) next

    tr_idx <- tr_start:tr_end
    y_tr   <- d[[target_col]][tr_idx]
    X_tr0  <- as.data.frame(d[tr_idx, pred_cols, drop = FALSE])

    # drop zero-variance cols within TRAIN to ensure PCs exist
    keep <- vapply(X_tr0, function(z) sd(z, na.rm=TRUE) > 0, logical(1))
    if (!any(keep)) next
    X_tr <- X_tr0[, keep, drop = FALSE]

    pnames <- paste0("P", seq_len(ncol(X_tr)))
    names(X_tr) <- pnames
    df_tr <- data.frame(y = y_tr, X_tr)

    Kcap <- min(Kmax, ncol(X_tr), length(tr_idx) - 2)
    if (Kcap <= 0) next

    fit <- pls::pcr(y ~ ., data = df_tr, scale = TRUE, validation = "none", ncomp = Kcap)

    # capture PCs once from the first successful window
    if (is.null(pc_info)) {
      pc_info <- inspect_pcr_components(fit, Kstar = min(Kstar_report, Kcap), topN = topN_report)
      pc_window <- list(train_start = d$date[tr_start], train_end = d$date[tr_end])
    }

    # BIC selection incl. K=0
    n_tr <- length(tr_idx)
    mu0  <- mean(y_tr, na.rm=TRUE)
    rss0 <- sum((y_tr - mu0)^2, na.rm=TRUE)
    bic0 <- n_tr * log(rss0 / n_tr) + 1 * log(n_tr)

    Ks   <- 1:Kcap
    rssK <- sapply(Ks, function(K){
      yhat_trK <- drop(predict(fit, ncomp = K, newdata = df_tr))
      sum((y_tr - yhat_trK)^2, na.rm=TRUE)
    })
    bicK <- n_tr * log(rssK / n_tr) + (Ks + 1) * log(n_tr)

    best_K <- which.min(c(bic0, bicK)) - 1
    K_pick[i] <- best_K

    # h-step forecast at decision time t = i - h (no look-ahead)
    X_i0 <- as.data.frame(d[i - h, pred_cols, drop = FALSE])
    X_i  <- X_i0[, keep, drop = FALSE]
    names(X_i) <- pnames
    df_i <- data.frame(y = NA_real_, X_i)

    yhat_pcr[i] <- if (best_K == 0) mu0 else drop(predict(fit, ncomp = best_K, newdata = df_i))
  }

  oos <- d %>%
    dplyr::mutate(f_pcr = yhat_pcr,
                  f_rw0 = yhat_rw0,
                  K_selected = K_pick) %>%
    dplyr::filter(!is.na(f_pcr))

  rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm=TRUE))
  e_pcr <- oos[[target_col]] - oos$f_pcr
  e_rw0 <- oos[[target_col]] - oos$f_rw0

  K_summary <- oos %>%
    dplyr::count(K_selected, name = "n_decisions") %>%
    dplyr::arrange(K_selected)

  summary <- tibble::tibble(
    horizon = paste0(h, "m"),
    window_W = W,
    first_decision_date = d$date[i_start],
    n_oos = nrow(oos),
    RMSE_PCR = rmse(oos[[target_col]], oos$f_pcr),
    RMSE_RW0 = rmse(oos[[target_col]], oos$f_rw0),
    R2_OOS_vs_RW0 = 1 - sum(e_pcr^2, na.rm=TRUE) / sum(e_rw0^2, na.rm=TRUE),
    K_avg = mean(oos$K_selected, na.rm=TRUE)
  )

  # ensure pc_info fields exist even if no window succeeded
  if (is.null(pc_info)) {
    pc_info <- list(
      pc_loadings = tibble::tibble(variable = character(0)),
      vx_report   = tibble::tibble(PC = character(0), var_explained_pct = numeric(0), cum_pct = numeric(0)),
      top_contrib = tibble::tibble(PC = character(0), variable = character(0), loading = numeric(0), contrib_pct = numeric(0)),
      scores      = matrix(numeric(0), 0, 0),
      ncomp       = 0L
    )
    pc_window <- list(train_start = NA, train_end = NA)
  }

  list(
    summary   = summary,
    oos       = oos,
    K_summary = K_summary,
    pc_loadings = pc_info$pc_loadings,
    vx_report   = pc_info$vx_report,
    top_contrib = pc_info$top_contrib,
    pc_window   = pc_window
  )
}
```


```{r}
base <- read_csv("../data/df_1m_lag.csv", show_col_types = FALSE) %>%
  select (-current_fx_level, -fx_level_fwd_1m)
target_col <- "Y_log_return_1m"
pred_cols <- setdiff(names(base), c("date", target_col))
h <- 1
cutoff <- as.Date("2012-12-01")

out_1m <- roll_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
out_1m$summary

# --- directional accuracy for 3m PCR (and RW0) ---
oos <- out_1m$oos %>%
  transmute(date,
            y    = !!rlang::sym(target_col),   # realized 3m return
            f_pcr = f_pcr,
            f_rw0 = f_rw0)

# Basic DA = share of times predicted and realized have the same sign
da <- function(y, yhat) mean(sign(y) == sign(yhat), na.rm = TRUE)

da_pcr <- da(oos$y, oos$f_pcr)
da_rw0 <- da(oos$y, oos$f_rw0)   # RW0 predicts 0 → DA is share of exact zeros in y

# Confusion matrix (signs: -1, 0, 1)
tab_sign <- table(truth = sign(oos$y), pred = sign(oos$f_pcr))

# --- compact summary ---
tibble::tibble(
  horizon        = "1m",
  n_oos          = nrow(oos),
  DA_PCR         = da_pcr,
  DA_RW0         = da_rw0,
) -> da_summary

print(da_summary)
```

```{r}
base <- read_csv("../data/df_3m_lag.csv", show_col_types = FALSE) %>%
  select (-current_fx_level, -fx_level_fwd_3m)
target_col <- "Y_log_return_3m"
pred_cols <- setdiff(names(base), c("date", target_col))
h <- 3
cutoff <- as.Date("2012-10-01")

out_3m <- roll_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
out_3m$summary

# --- directional accuracy for 3m PCR (and RW0) ---
oos <- out_3m$oos %>%
  transmute(date,
            y    = !!rlang::sym(target_col),   # realized 3m return
            f_pcr = f_pcr,
            f_rw0 = f_rw0)

# Basic DA = share of times predicted and realized have the same sign
da <- function(y, yhat) mean(sign(y) == sign(yhat), na.rm = TRUE)

da_pcr <- da(oos$y, oos$f_pcr)
da_rw0 <- da(oos$y, oos$f_rw0)   # RW0 predicts 0 → DA is share of exact zeros in y

# Confusion matrix (signs: -1, 0, 1)
tab_sign <- table(truth = sign(oos$y), pred = sign(oos$f_pcr))

# --- compact summary ---
tibble::tibble(
  horizon        = "3m",
  n_oos          = nrow(oos),
  DA_PCR         = da_pcr,
  DA_RW0         = da_rw0,
) -> da_summary

print(da_summary)
```


```{r}
base <- read_csv("../data/df_6m_lag.csv", show_col_types = FALSE) %>%
  select (-current_fx_level, -fx_level_fwd_6m)
target_col <- "Y_log_return_6m"
pred_cols <- setdiff(names(base), c("date", target_col))
h <- 6
cutoff <- as.Date("2012-07-01")

out_6m <- roll_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
out_6m$summary

# --- directional accuracy for 6m PCR (and RW0) ---
oos <- out_6m$oos %>%
  transmute(date,
            y    = !!rlang::sym(target_col),   # realized 6m return
            f_pcr = f_pcr,
            f_rw0 = f_rw0)

# Basic DA = share of times predicted and realized have the same sign
da <- function(y, yhat) mean(sign(y) == sign(yhat), na.rm = TRUE)

da_pcr <- da(oos$y, oos$f_pcr)
da_rw0 <- da(oos$y, oos$f_rw0)   # RW0 predicts 0 → DA is share of exact zeros in y

# Confusion matrix (signs: -1, 0, 1)
tab_sign <- table(truth = sign(oos$y), pred = sign(oos$f_pcr))

# --- compact summary ---
tibble::tibble(
  horizon        = "6m",
  n_oos          = nrow(oos),
  DA_PCR         = da_pcr,
  DA_RW0         = da_rw0,
) -> da_summary

print(da_summary)
out_6m$K_summary
out_6m$pc_report
```



```{r}
base <- read_csv("../data/df_12m_lag.csv", show_col_types = FALSE) %>%
  select (-current_fx_level, -fx_level_fwd_12m)
target_col <- "Y_log_return_12m"
pred_cols <- setdiff(names(base), c("date", target_col))
h <- 12
cutoff <- as.Date("2012-01-01")
out_12m <- roll_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
out_12m$summary

# --- directional accuracy for 12m PCR (and RW0) ---
oos <- out_12m$oos %>%
  transmute(date,
            y    = !!rlang::sym(target_col),   # realized 12m return
            f_pcr = f_pcr,
            f_rw0 = f_rw0)

# Basic DA = share of times predicted and realized have the same sign
da <- function(y, yhat) mean(sign(y) == sign(yhat), na.rm = TRUE)

da_pcr <- da(oos$y, oos$f_pcr)
da_rw0 <- da(oos$y, oos$f_rw0)   # RW0 predicts 0 → DA is share of exact zeros in y

# Confusion matrix (signs: -1, 0, 1)
tab_sign <- table(truth = sign(oos$y), pred = sign(oos$f_pcr))

# --- compact summary ---
tibble::tibble(
  horizon        = "12m",
  n_oos          = nrow(oos),
  DA_PCR         = da_pcr,
  DA_RW0         = da_rw0,
) -> da_summary

print(da_summary)
tab_sign
out_12m$K_summary
out_12m$pc_report
out_12m$top_contrib

```

### fixed train test
```{r}
# -------- fixed train/test PCR (horizon-aware), BIC-picked K, same style as rolling --------
fixed_pcr_bic_pls <- function(dat, target_col, pred_cols, h, cutoff_date, Kmax = 10) {
  d <- dat %>%
    select(date, all_of(target_col), all_of(pred_cols)) %>%
    arrange(date) %>%
    drop_na(!!rlang::sym(target_col), all_of(pred_cols))

  # horizon-aware train/test split
  train_end <- cutoff_date %m-% months(h)
  train <- d %>% filter(date <= train_end)
  test  <- d %>% filter(date  >  cutoff_date)

  if (nrow(train) < 12) stop("Too few rows before cutoff-h for training.")
  if (nrow(test)  <  1) stop("No test rows after cutoff.")

  # --- sanitize predictor names like in rolling version ---
  X_tr <- as.data.frame(train[, pred_cols, drop = FALSE])
  pnames <- paste0("P", seq_len(ncol(X_tr)))
  names(X_tr) <- pnames
  df_tr <- data.frame(y = train[[target_col]], X_tr)

  # cap number of components
  Kcap <- min(Kmax, ncol(X_tr), nrow(X_tr) - 2)
  if (Kcap <= 0) stop("Kcap <= 0 (not enough df/predictors).")

  # fit PCR on TRAIN ONLY (same as rolling: scale=TRUE, validation='none')
  fit <- pls::pcr(y ~ ., data = df_tr, scale = TRUE, validation = "none", ncomp = Kcap)

  # ---- BIC over K = 0..Kcap on TRAIN (same logic as rolling) ----
  n_tr <- nrow(df_tr)
  y_tr <- df_tr$y
  mu0  <- mean(y_tr, na.rm = TRUE)
  rss0 <- sum((y_tr - mu0)^2, na.rm = TRUE)
  bic0 <- n_tr * log(rss0 / n_tr) + 1 * log(n_tr)   # intercept-only

  Ks    <- 1:Kcap
  rssK  <- sapply(Ks, function(K) {
    yhat_trK <- drop(predict(fit, ncomp = K, newdata = df_tr))
    sum((y_tr - yhat_trK)^2, na.rm = TRUE)
  })
  bicK  <- n_tr * log(rssK / n_tr) + (Ks + 1) * log(n_tr)  # +1 for intercept

  best_K <- which.min(c(bic0, bicK)) - 1  # 0..Kcap

  # ---- predict TEST (once) ----
  X_te <- as.data.frame(test[, pred_cols, drop = FALSE])
  names(X_te) <- pnames                      # same sanitized names
  df_te <- data.frame(y = NA_real_, X_te)    # dummy y for predict()

  f_pcr <- if (best_K == 0) rep(mu0, nrow(df_te)) else drop(predict(fit, ncomp = best_K, newdata = df_te))
  f_rw0 <- rep(0, nrow(df_te))

  oos <- test %>% mutate(f_pcr = f_pcr, f_rw0 = f_rw0)

  # ---- metrics (RMSE, R2 vs RW0, Directional Accuracy) ----
  rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
  y    <- oos[[target_col]]
  e_p  <- y - oos$f_pcr
  e_rw <- y - oos$f_rw0

  da <- function(y, yhat, drop_zero = TRUE) {
    sy <- sign(y); sf <- sign(yhat)
    ok <- is.finite(sy) & is.finite(sf)
    if (drop_zero) ok <- ok & sy != 0 & sf != 0
    if (!any(ok)) return(NA_real_)
    mean(sy[ok] == sf[ok])
  }

  summary <- tibble(
    horizon            = paste0(h, "m"),
    train_end          = train_end,
    cutoff_date        = cutoff_date,
    K_selected         = best_K,
    n_train            = nrow(train),
    n_test             = nrow(test),
    test_start         = min(test$date),
    test_end           = max(test$date),
    RMSE_PCR           = rmse(y, oos$f_pcr),
    RMSE_RW0           = rmse(y, oos$f_rw0),
    R2_OOS_vs_RW0      = 1 - sum(e_p^2) / sum(e_rw^2),
    DA_PCR             = da(y, oos$f_pcr, drop_zero = TRUE),
    DA_RW0             = da(y, oos$f_rw0, drop_zero = TRUE)
  )

  list(summary = summary, oos = oos %>% select(date, !!target_col, f_pcr, f_rw0))
}
```


```{r}
cutoff <- as.Date("2012-12-01")

run_fixed <- function(path, target_col, h) {
  base <- readr::read_csv(path, show_col_types = FALSE) %>%
    mutate(date = as.Date(date)) %>%
    arrange(date) %>%
    # drop helper columns if present; harmless if absent
    dplyr::select(-dplyr::any_of(c("current_fx_level","fx_level_fwd_1m","fx_level_fwd_3m","fx_level_fwd_6m","fx_level_fwd_12m"))) %>%
    tidyr::drop_na(!!rlang::sym(target_col))

  pred_cols <- setdiff(names(base), c("date", target_col))
  pred_cols <- pred_cols[sapply(base[pred_cols], is.numeric)]  # numeric only

  fixed_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
}

out_1m  <- run_fixed("../data/df_1m_lag.csv",  "Y_log_return_1m",  1)
out_3m  <- run_fixed("../data/df_3m_lag.csv",  "Y_log_return_3m",  3)
out_6m  <- run_fixed("../data/df_6m_lag.csv",  "Y_log_return_6m",  6)
out_12m <- run_fixed("../data/df_12m_lag.csv", "Y_log_return_12m", 12)

dplyr::bind_rows(
  out_1m$summary,
  out_3m$summary,
  out_6m$summary,
  out_12m$summary
) %>% print()

```







