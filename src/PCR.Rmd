---
title: "PCR"
author: "Erica"
date: "2025-11-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(lubridate)
library(tidyr)
```

```{r}
roll_pcr_bic_pls <- function(dat, target_col, pred_cols, h, cutoff_date, Kmax = 10) {
  d <- dat %>%
    select(date, all_of(target_col), all_of(pred_cols)) %>%
    arrange(date) %>%
    drop_na(!!rlang::sym(target_col), all_of(pred_cols))

  # Fixed window length = rows up to cutoff
  W <- d %>% filter(date <= cutoff_date) %>% nrow()
  if (W < 12) stop("Not enough rows before cutoff to form a window.")

  # First decision date = cutoff + h months
  D0 <- cutoff_date %m+% months(h)
  i_start <- which(d$date == D0)
  if (length(i_start) == 0) stop("First decision date not found in data (check dates).")

  n <- nrow(d)
  yhat_pcr <- rep(NA_real_, n)
  yhat_rw0 <- rep(0, n)  # RW(0) baseline for returns

  for (i in i_start:n) {
    tr_end   <- i - h
    tr_start <- tr_end - W + 1
    if (tr_start < 1) next

    tr_idx <- tr_start:tr_end
    y_tr   <- d[[target_col]][tr_idx]
    X_tr   <- as.data.frame(d[tr_idx, pred_cols, drop = FALSE])

    # make syntactic, short predictor names
    pnames <- paste0("P", seq_len(ncol(X_tr)))
    names(X_tr) <- pnames

    # cap number of components
    Kcap <- min(Kmax, ncol(X_tr), length(tr_idx) - 2)
    if (Kcap <= 0) next

    # fit PCR on training window (formula y ~ .)
    df_tr <- data.frame(y = y_tr, X_tr)
    fit   <- pls::pcr(y ~ ., data = df_tr, scale = TRUE, validation = "none", ncomp = Kcap)

    # ---- BIC over K = 0..Kcap on TRAINING window ----
    n_tr <- length(tr_idx)
    mu0  <- mean(y_tr, na.rm = TRUE)
    rss0 <- sum((y_tr - mu0)^2, na.rm = TRUE)
    bic0 <- n_tr * log(rss0 / n_tr) + 1 * log(n_tr)   # intercept-only

    Ks    <- 1:Kcap
    rssK  <- sapply(Ks, function(K) {
      yhat_trK <- drop(predict(fit, ncomp = K, newdata = df_tr))
      sum((y_tr - yhat_trK)^2, na.rm = TRUE)
    })
    bicK  <- n_tr * log(rssK / n_tr) + (Ks + 1) * log(n_tr)  # +1 for intercept

    best_K <- which.min(c(bic0, bicK)) - 1  # 0..Kcap

    # ---- predict for decision row i ----
    X_i <- as.data.frame(d[i, pred_cols, drop = FALSE])
    names(X_i) <- pnames                      # same names as training
    df_i <- data.frame(y = NA_real_, X_i)     # dummy y column for predict()

    yhat_pcr[i] <- if (best_K == 0) mu0 else drop(predict(fit, ncomp = best_K, newdata = df_i))
}

  # Collect OOS
  oos <- d %>%
    mutate(f_pcr = yhat_pcr,
           f_rw0 = yhat_rw0) %>%
    filter(!is.na(f_pcr))

  rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
  e_pcr <- oos[[target_col]] - oos$f_pcr
  e_rw0 <- oos[[target_col]] - oos$f_rw0

  summary <- tibble::tibble(
    horizon = paste0(h, "m"),
    window_W = W,
    first_decision_date = d$date[i_start],
    n_oos = nrow(oos),
    RMSE_PCR = rmse(oos[[target_col]], oos$f_pcr),
    RMSE_RW0 = rmse(oos[[target_col]], oos$f_rw0),
    R2_OOS_vs_RW0 = 1 - sum(e_pcr^2) / sum(e_rw0^2)
  )

  list(summary = summary, oos = oos)
}

```


```{r}
base <- read_csv("../data/df_1m_lag.csv", show_col_types = FALSE) %>%
  select (-current_fx_level, -fx_level_fwd_1m)
target_col <- "Y_log_return_1m"
pred_cols <- setdiff(names(base), c("date", target_col))
h <- 1
cutoff <- as.Date("2012-12-01")

out_1m <- roll_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
out_1m$summary

# --- directional accuracy for 3m PCR (and RW0) ---
oos <- out_1m$oos %>%
  transmute(date,
            y    = !!rlang::sym(target_col),   # realized 3m return
            f_pcr = f_pcr,
            f_rw0 = f_rw0)

# Basic DA = share of times predicted and realized have the same sign
da <- function(y, yhat) mean(sign(y) == sign(yhat), na.rm = TRUE)

da_pcr <- da(oos$y, oos$f_pcr)
da_rw0 <- da(oos$y, oos$f_rw0)   # RW0 predicts 0 → DA is share of exact zeros in y

# Confusion matrix (signs: -1, 0, 1)
tab_sign <- table(truth = sign(oos$y), pred = sign(oos$f_pcr))

# --- compact summary ---
tibble::tibble(
  horizon        = "1m",
  n_oos          = nrow(oos),
  DA_PCR         = da_pcr,
  DA_RW0         = da_rw0,
) -> da_summary

print(da_summary)
```

```{r}
base <- read_csv("../data/df_3m_lag.csv", show_col_types = FALSE) %>%
  select (-current_fx_level, -fx_level_fwd_3m)
target_col <- "Y_log_return_3m"
pred_cols <- setdiff(names(base), c("date", target_col))
h <- 3
cutoff <- as.Date("2012-12-01")

out_3m <- roll_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
out_3m$summary

# --- directional accuracy for 3m PCR (and RW0) ---
oos <- out_3m$oos %>%
  transmute(date,
            y    = !!rlang::sym(target_col),   # realized 3m return
            f_pcr = f_pcr,
            f_rw0 = f_rw0)

# Basic DA = share of times predicted and realized have the same sign
da <- function(y, yhat) mean(sign(y) == sign(yhat), na.rm = TRUE)

da_pcr <- da(oos$y, oos$f_pcr)
da_rw0 <- da(oos$y, oos$f_rw0)   # RW0 predicts 0 → DA is share of exact zeros in y

# Confusion matrix (signs: -1, 0, 1)
tab_sign <- table(truth = sign(oos$y), pred = sign(oos$f_pcr))

# --- compact summary ---
tibble::tibble(
  horizon        = "3m",
  n_oos          = nrow(oos),
  DA_PCR         = da_pcr,
  DA_RW0         = da_rw0,
) -> da_summary

print(da_summary)
```


```{r}
base <- read_csv("../data/df_6m_lag.csv", show_col_types = FALSE) %>%
  select (-current_fx_level, -fx_level_fwd_6m)
target_col <- "Y_log_return_6m"
pred_cols <- setdiff(names(base), c("date", target_col))
h <- 6
cutoff <- as.Date("2012-12-01")

out_6m <- roll_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
out_6m$summary

# --- directional accuracy for 6m PCR (and RW0) ---
oos <- out_6m$oos %>%
  transmute(date,
            y    = !!rlang::sym(target_col),   # realized 6m return
            f_pcr = f_pcr,
            f_rw0 = f_rw0)

# Basic DA = share of times predicted and realized have the same sign
da <- function(y, yhat) mean(sign(y) == sign(yhat), na.rm = TRUE)

da_pcr <- da(oos$y, oos$f_pcr)
da_rw0 <- da(oos$y, oos$f_rw0)   # RW0 predicts 0 → DA is share of exact zeros in y

# Confusion matrix (signs: -1, 0, 1)
tab_sign <- table(truth = sign(oos$y), pred = sign(oos$f_pcr))

# --- compact summary ---
tibble::tibble(
  horizon        = "6m",
  n_oos          = nrow(oos),
  DA_PCR         = da_pcr,
  DA_RW0         = da_rw0,
) -> da_summary

print(da_summary)
```

```{r}
base <- read_csv("../data/df_12m_lag.csv", show_col_types = FALSE) %>%
  select (-current_fx_level, -fx_level_fwd_12m)
target_col <- "Y_log_return_12m"
pred_cols <- setdiff(names(base), c("date", target_col))
h <- 12
cutoff <- as.Date("2012-12-01")
out_12m <- roll_pcr_bic_pls(base, target_col, pred_cols, h, cutoff, Kmax = 10)
out_12m$summary

# --- directional accuracy for 12m PCR (and RW0) ---
oos <- out_12m$oos %>%
  transmute(date,
            y    = !!rlang::sym(target_col),   # realized 12m return
            f_pcr = f_pcr,
            f_rw0 = f_rw0)

# Basic DA = share of times predicted and realized have the same sign
da <- function(y, yhat) mean(sign(y) == sign(yhat), na.rm = TRUE)

da_pcr <- da(oos$y, oos$f_pcr)
da_rw0 <- da(oos$y, oos$f_rw0)   # RW0 predicts 0 → DA is share of exact zeros in y

# Confusion matrix (signs: -1, 0, 1)
tab_sign <- table(truth = sign(oos$y), pred = sign(oos$f_pcr))

# --- compact summary ---
tibble::tibble(
  horizon        = "12m",
  n_oos          = nrow(oos),
  DA_PCR         = da_pcr,
  DA_RW0         = da_rw0,
) -> da_summary

print(da_summary)
tab_sign
```

```{r}

```









